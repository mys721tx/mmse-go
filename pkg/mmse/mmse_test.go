// mmso-go: Motorsport Manager save edit suite
// Copyright (C) 2018  Yishen Miao
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

package mmse_test

import (
	"bytes"
	"encoding/binary"
	"io"
	"os"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"github.com/mys721tx/mmse-go/pkg/mmse"
)

// MockReader is an autogenerated mock type for the Reader type
type MockReader struct {
	mock.Mock
}

// Read provides a mock function with given fields: p
func (_m *MockReader) Read(p []byte) (int, error) {
	ret := _m.Called(p)

	var r0 int
	if rf, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = rf(p)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWriter is an autogenerated mock type for the Writer type
type MockWriter struct {
	mock.Mock
}

// MockWrite provides a mock function with given fields: p
func (_m *MockWriter) Write(p []byte) (int, error) {
	ret := _m.Called(p)

	var r0 int
	if rf, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = rf(p)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

func TestReadInt32(t *testing.T) {

	r := bytes.NewBuffer([]byte{0xff, 0xff, 0xff, 0x7f})

	v, err := mmse.ReadInt32(r)

	if assert.NoError(t, err) {
		assert.Equal(
			t, v, int32(0x7fffffff),
			"ReadInt32 should read a little endian int32.",
		)
	}
}

func TestReadInt32ReaderError(t *testing.T) {

	r := new(MockReader)

	errs := []error{
		io.EOF,
		io.ErrUnexpectedEOF,
	}

	for _, e := range errs {
		r.On("Read", mock.Anything).Return(1, e)

		v, err := mmse.ReadInt32(r)

		if assert.Error(t, err) {
			assert.Equal(
				t, v, int32(0),
				"ReadInt32 should return 0 if the io.Reader fails.",
			)
		}
	}
}

func TestWriteInt32(t *testing.T) {

	w := new(bytes.Buffer)

	err := mmse.WriteInt32(w, int32(0x7fffffff))

	if assert.NoError(t, err) {
		assert.Equal(
			t, w.Bytes(), []byte{0xff, 0xff, 0xff, 0x7f},
			"WriteInt32 should write a little endian int32.",
		)
	}
}

func TestWriteInt32WriterError(t *testing.T) {

	w := new(MockWriter)

	errs := []error{
		os.ErrPermission,
		os.ErrNotExist,
		os.ErrClosed,
		io.EOF,
		io.ErrUnexpectedEOF,
	}

	for _, e := range errs {
		w.On("Write", mock.Anything).Return(0, e)

		err := mmse.WriteInt32(w, int32(0x7fffffff))

		assert.Error(t, err,
			"WriteInt32 should error if the io.Writer fails.",
		)
	}
}

func TestReadSizeToFrame(t *testing.T) {

	r := new(bytes.Buffer)

	int32s := []int32{0x7fffffff, 0x00000001}

	binary.Write(r, binary.LittleEndian, int32s)

	f := mmse.ReadSizeToFrame(r)

	assert.Equal(
		t, f.SizeCom, int32s[0],
		"SizeCom should be the first byte field.",
	)

	assert.Equal(
		t, f.SizeRaw, int32s[1],
		"SizeRaw should be the first byte field.",
	)
}

func TestReadSizeToFrameReaderError(t *testing.T) {

	r := new(MockReader)

	errs := []error{
		io.EOF,
		io.ErrUnexpectedEOF,
	}

	for _, e := range errs {
		r.On("Read", mock.Anything).Return(0, e)

		assert.Panics(
			t, func() { mmse.ReadSizeToFrame(r) },
			"ReadSizeToFrame should panic if fails to read SizeCom.",
		)
	}
}
